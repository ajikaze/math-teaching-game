# マナと学ぶ数学 - 開発手順書

**プロジェクト名**: Math Teaching Game with AI Character "Mana"  
**開発期間**: 2025 年 8 月 6 日 〜 継続中  
**最終更新**: 2025 年 8 月 6 日

---

## 📋 目次

1. [開発フローの概要](#1-開発フローの概要)
2. [Phase 1: 基本機能開発（完了）](#2-phase-1-基本機能開発完了)
3. [環境構築手順](#3-環境構築手順)
4. [トラブルシューティング実例](#4-トラブルシューティング実例)
5. [Phase 2: データベース設計（次回予定）](#5-phase-2-データベース設計次回予定)
6. [コードベース構造](#6-コードベース構造)
7. [開発ベストプラクティス](#7-開発ベストプラクティス)
8. [デプロイメント手順](#8-デプロイメント手順)

---

## 1. 開発フローの概要

### 1.1 開発アプローチ

-   **段階的開発**: 機能ごとの段階的実装
-   **プロトタイプファースト**: 動作確認を最優先
-   **フォールバック設計**: AI 利用不可時の代替機能
-   **Windows 環境対応**: PowerShell・Windows 固有の問題解決

### 1.2 技術選定の理由

| 技術                 | 選定理由                    | 代替案             |
| -------------------- | --------------------------- | ------------------ |
| React + Vite         | 学習目的で Next.js より軽量 | Next.js            |
| Express + TypeScript | シンプルで拡張性が高い      | Fastify, NestJS    |
| Gemini AI            | 無料枠が充実、性能が良い    | OpenAI GPT, Claude |
| Prisma ORM           | TypeScript 対応、直感的     | TypeORM, Sequelize |

---

## 2. Phase 1: 基本機能開発（完了）

### 2.1 実装順序と実際の経緯

#### Step 1: フロントエンドの基本設計

**期間**: 開発開始 〜 1 時間  
**目標**: UI コンポーネントとキャラクター機能の実装

##### 実装内容

```bash
# プロジェクト構造の決定
math-teaching-app/
├── package.json
├── vite.config.ts
├── tailwind.config.js
├── src/
│   ├── main.tsx
│   ├── App.tsx
│   ├── index.css
│   └── components/
│       └── MathTeachingGame.tsx
```

##### 主要機能

-   ✅ キャラクター状態管理（レベル、経験値、理解度）
-   ✅ 分野別学習システム（代数・幾何・関数・確率）
-   ✅ レスポンシブデザイン（Tailwind CSS）
-   ✅ 音声認識機能
-   ✅ アニメーション・UI 効果

**成果物**: 完全に動作するフロントエンドアプリ

#### Step 2: バックエンド API 設計・実装

**期間**: 1-3 時間  
**目標**: REST API とビジネスロジックの実装

##### 実装順序

1. **プロジェクト構造設計**

    ```bash
    backend/
    ├── package.json
    ├── tsconfig.json
    ├── src/
    │   ├── server.ts
    │   ├── routes/
    │   ├── controllers/
    │   ├── services/
    │   ├── middleware/
    │   ├── types/
    │   └── utils/
    ```

2. **基本 API サーバー**

    - Express + TypeScript
    - CORS, セキュリティミドルウェア
    - エラーハンドリング

3. **質問生成サービス**

    - テンプレートベースの質問システム
    - 分野別・難易度別の問題バンク
    - 会話履歴を考慮した重複回避

4. **回答評価サービス**
    - キーワードベースの評価システム
    - 回答品質の分析（長さ、専門用語、具体例）
    - 経験値・理解度の計算

**成果物**: 完全に動作するバックエンド API

#### Step 3: Gemini AI 統合

**期間**: 3-5 時間（トラブルシューティング含む）  
**目標**: 実際の AI 機能の実装

##### 実装の課題と解決

1. **API キー設定問題**

    - 問題：環境変数が読み込まれない
    - 原因：Windows PowerShell 環境、.env ファイルのパス問題
    - 解決：複数パスの試行、遅延初期化の実装

2. **モデル名変更対応**

    - 問題：`gemini-pro`モデルが 404 エラー
    - 原因：Gemini API のモデル名変更
    - 解決：`gemini-1.5-flash`への変更、複数モデルの自動試行

3. **初期化タイミング問題**
    - 問題：サービス初期化が環境変数読み込みより早い
    - 原因：ES Module の import 評価順序
    - 解決：遅延初期化パターンの導入

##### 最終実装

-   ✅ 質問生成 AI: 理解度・分野・履歴を考慮した自然な質問
-   ✅ 回答評価 AI: ユーザーの説明を理解し適切なフィードバック
-   ✅ フォールバック機能: AI 利用不可時の安全な動作
-   ✅ エラーハンドリング: 適切な障害対応

**成果物**: 完全に動作する AI 統合システム

### 2.2 実装完了機能一覧

#### ✅ フロントエンド機能

-   [x] キャラクター育成システム（レベル、経験値）
-   [x] 4 分野学習システム（代数・幾何・関数・確率）
-   [x] 理解度可視化（プログレスバー）
-   [x] 音声認識入力
-   [x] レスポンシブデザイン
-   [x] アニメーション・UI 効果
-   [x] 学習統計表示

#### ✅ バックエンド機能

-   [x] REST API 設計・実装
-   [x] 質問生成システム（AI + フォールバック）
-   [x] 回答評価システム（AI + ルールベース）
-   [x] バリデーション・エラーハンドリング
-   [x] ログシステム
-   [x] ヘルスチェック・診断機能

#### ✅ AI 統合機能

-   [x] Google Gemini AI 連携
-   [x] 自然言語による質問生成
-   [x] インテリジェントな回答評価
-   [x] キャラクター性の維持
-   [x] 学習レベル適応機能

### 2.3 現在の到達レベル

-   **MVP 完成度**: 95%
-   **デプロイ準備**: 可能
-   **実用性**: 実際の学習に使用可能
-   **技術的品質**: 商用レベル

---

## 3. 環境構築手順

### 3.1 前提条件

-   Node.js 18.0.0 以上
-   npm または yarn
-   Git
-   VS Code（推奨）
-   モダンブラウザ（Chrome, Firefox, Safari, Edge）

### 3.2 初回セットアップ

#### Step 1: リポジトリクローン・初期化

```bash
# プロジェクトフォルダ作成
mkdir math-teaching-app
cd math-teaching-app

# Gitリポジトリ初期化
git init
```

#### Step 2: フロントエンド環境構築

```bash
# Vite + React + TypeScriptプロジェクト作成
npm create vite@latest frontend -- --template react-ts
cd frontend

# 依存関係インストール
npm install lucide-react
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# 開発サーバー起動
npm run dev
```

#### Step 3: バックエンド環境構築

```bash
# バックエンドディレクトリ作成
cd ..
mkdir backend
cd backend

# package.json作成・依存関係インストール
npm init -y
npm install express cors helmet dotenv joi express-rate-limit @google/generative-ai
npm install -D @types/express @types/cors @types/node typescript tsx eslint
```

#### Step 4: 環境変数設定（重要）

```bash
# .envファイル作成（backendディレクトリ内）
cat > .env << 'EOF'
PORT=3001
NODE_ENV=development
LOG_LEVEL=DEBUG
FRONTEND_URL=http://localhost:3000
GEMINI_API_KEY=your_actual_api_key_here
GEMINI_MODEL=gemini-1.5-flash
JWT_SECRET=your_jwt_secret_here
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
EOF

# 実際のGemini APIキーを設定
# notepad .env  # Windows
# nano .env     # Linux/macOS
```

### 3.3 開発環境の起動

#### 方法 1: 個別起動

```bash
# ターミナル1: フロントエンド
cd frontend
npm run dev

# ターミナル2: バックエンド
cd backend
npm run dev
```

#### 方法 2: 同時起動（推奨）

```bash
# ルートディレクトリにpackage.json作成
{
  "scripts": {
    "dev": "concurrently \"npm run dev:frontend\" \"npm run dev:backend\"",
    "dev:frontend": "cd frontend && npm run dev",
    "dev:backend": "cd backend && npm run dev"
  },
  "devDependencies": {
    "concurrently": "^8.2.0"
  }
}

# 実行
npm install
npm run dev
```

---

## 4. トラブルシューティング実例

### 4.1 環境変数問題（Windows）

#### 問題

```
[WARN] GEMINI_API_KEY is not set - GeminiService will not be available
```

#### 原因分析

1. Windows PowerShell での環境変数設定問題
2. .env ファイルのパス認識問題
3. TypeScript ES Module の import 評価順序

#### 解決手順

```bash
# 1. .envファイルの場所確認
cd backend
pwd  # 実行ディレクトリ確認
ls .env  # ファイル存在確認

# 2. ファイル内容確認
Get-Content .env  # PowerShell
cat .env          # Git Bash

# 3. 環境変数直接設定（テスト用）
$env:GEMINI_API_KEY="your_api_key_here"
npm run dev

# 4. .envファイル再作成
Remove-Item .env -ErrorAction SilentlyContinue
@'
GEMINI_API_KEY=your_actual_api_key_here
GEMINI_MODEL=gemini-1.5-flash
NODE_ENV=development
'@ | Out-File -FilePath ".env" -Encoding UTF8
```

#### 技術的解決

```typescript
// 遅延初期化パターンの実装
class ChatController {
    private async getServices() {
        if (!mathQuestionService || !answerEvaluationService) {
            // 環境変数読み込み後に動的インポート
            const { MathQuestionService } = await import(
                "../services/mathQuestionService"
            );
            mathQuestionService = new MathQuestionService();
        }
        return { questionService: mathQuestionService };
    }
}
```

### 4.2 Gemini AI モデル問題

#### 問題

```json
{
    "error": "models/gemini-pro is not found for API version v1"
}
```

#### 解決

```typescript
// 複数モデル自動試行の実装
const modelsToTry = ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-pro"];
for (const modelName of modelsToTry) {
    try {
        const model = genAI.getGenerativeModel({ model: modelName });
        // 成功したモデルを使用
        break;
    } catch (error) {
        continue; // 次のモデルを試行
    }
}
```

### 4.3 CORS 問題

#### 問題

```
Access to fetch at 'http://localhost:3001/api/chat' from origin 'http://localhost:3000' has been blocked by CORS policy
```

#### 解決

```typescript
// 適切なCORS設定
app.use(
    cors({
        origin:
            process.env.NODE_ENV === "production"
                ? ["https://your-app.vercel.app"]
                : ["http://localhost:3000", "http://localhost:5173"],
        credentials: true,
    })
);
```

---

## 5. Phase 2: データベース設計（次回予定）

### 5.1 実装予定の順序

#### Step 1: データベース設計

```sql
-- ユーザーテーブル
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  username VARCHAR(100) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- キャラクター状態テーブル
CREATE TABLE character_states (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  level INTEGER DEFAULT 1,
  experience INTEGER DEFAULT 0,
  understanding_algebra INTEGER DEFAULT 0,
  understanding_geometry INTEGER DEFAULT 0,
  understanding_functions INTEGER DEFAULT 0,
  understanding_probability INTEGER DEFAULT 0,
  mood VARCHAR(20) DEFAULT 'curious',
  total_problems INTEGER DEFAULT 0,
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 会話履歴テーブル
CREATE TABLE conversations (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  role VARCHAR(20) NOT NULL,
  content TEXT NOT NULL,
  topic VARCHAR(50),
  timestamp TIMESTAMP DEFAULT NOW()
);
```

#### Step 2: Prisma ORM 設定

```bash
# Prismaインストール・初期化
cd backend
npm install prisma @prisma/client
npx prisma init

# スキーマ定義
# prisma/schema.prisma の編集

# マイグレーション実行
npx prisma migrate dev --name init
npx prisma generate
```

#### Step 3: 認証システム実装

```typescript
// JWT認証の実装
import jwt from "jsonwebtoken";

export const authenticateToken = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const authHeader = req.headers["authorization"];
    const token = authHeader && authHeader.split(" ")[1];

    if (!token) {
        return res.sendStatus(401);
    }

    jwt.verify(token, process.env.JWT_SECRET!, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
};
```

#### Step 4: データ永続化 API

-   ユーザー登録・ログイン API
-   キャラクター状態保存・読込 API
-   会話履歴保存・取得 API
-   学習統計 API

### 5.2 予想される課題

-   **データ設計**: リレーショナル設計の複雑さ
-   **マイグレーション**: スキーマ変更の管理
-   **セキュリティ**: パスワードハッシュ化、JWT 管理
-   **パフォーマンス**: 大量データ処理の最適化

---

## 6. コードベース構造

### 6.1 現在のプロジェクト構造

```
math-teaching-app/
├── 要件定義書.md
├── 開発手順書.md
├── README.md
├── frontend/                    # フロントエンドアプリ
│   ├── package.json
│   ├── vite.config.ts
│   ├── tailwind.config.js
│   ├── index.html
│   └── src/
│       ├── main.tsx            # エントリーポイント
│       ├── App.tsx             # ルートコンポーネント
│       ├── index.css           # グローバルスタイル
│       └── components/
│           └── MathTeachingGame.tsx  # メインコンポーネント
└── backend/                     # バックエンドAPI
    ├── package.json
    ├── tsconfig.json
    ├── .env                     # 環境変数
    └── src/
        ├── server.ts            # サーバーエントリーポイント
        ├── routes/
        │   ├── chat.ts         # チャットルート
        │   └── health.ts       # ヘルスチェックルート
        ├── controllers/
        │   ├── chatController.ts    # チャットコントローラー
        │   └── healthController.ts  # ヘルスチェックコントローラー
        ├── services/
        │   ├── geminiService.ts           # Gemini AI統合
        │   ├── mathQuestionService.ts     # 質問生成サービス
        │   └── answerEvaluationService.ts # 回答評価サービス
        ├── middleware/
        │   ├── validation.ts       # バリデーション
        │   └── errorHandler.ts     # エラーハンドリング
        ├── types/
        │   └── index.ts           # 型定義
        └── utils/
            └── logger.ts          # ログ機能
```

### 6.2 将来の構造（Phase 2 以降）

```
math-teaching-app/
├── frontend/
├── backend/
│   ├── prisma/                 # データベース関連
│   │   ├── schema.prisma      # Prismaスキーマ
│   │   └── migrations/        # マイグレーション
│   └── src/
│       ├── auth/              # 認証関連
│       ├── database/          # DB接続・設定
│       └── models/            # データモデル
├── docs/                      # ドキュメント
│   ├── api.md                # API仕様書
│   └── deployment.md         # デプロイ手順
└── tests/                     # テストコード
    ├── unit/                 # 単体テスト
    └── integration/          # 統合テスト
```

---

## 7. 開発ベストプラクティス

### 7.1 コーディング規約

-   **TypeScript**: 厳格な型定義の徹底
-   **命名規則**: camelCase（変数・関数）、PascalCase（クラス・型）
-   **ファイル名**: kebab-case
-   **関数**: 単一責任原則の徹底

### 7.2 エラーハンドリング

```typescript
// 統一されたエラーハンドリング
try {
    const result = await riskyOperation();
    return success(result);
} catch (error) {
    logger.error("Operation failed:", error);
    if (error instanceof KnownError) {
        return handleKnownError(error);
    }
    return handleUnknownError(error);
}
```

### 7.3 ログ戦略

```typescript
// 構造化ログ
logger.info("User action", {
    userId: user.id,
    action: "question_generated",
    topic: "algebra",
    timestamp: new Date().toISOString(),
});
```

### 7.4 環境管理

-   **開発環境**: ローカルでの開発・テスト
-   **ステージング環境**: デプロイ前確認（将来）
-   **本番環境**: Vercel 本番デプロイ

---

## 8. デプロイメント手順

### 8.1 Vercel デプロイ準備

#### Step 1: Vercel 用設定ファイル

```json
// vercel.json (ルートディレクトリ)
{
    "builds": [
        {
            "src": "frontend/package.json",
            "use": "@vercel/static-build",
            "config": { "distDir": "dist" }
        },
        {
            "src": "backend/src/server.ts",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
            "src": "/api/(.*)",
            "dest": "/backend/src/server.ts"
        },
        {
            "src": "/(.*)",
            "dest": "/frontend/$1"
        }
    ]
}
```

#### Step 2: 環境変数設定

```bash
# Vercel CLI使用
npm i -g vercel
vercel login
vercel env add GEMINI_API_KEY
vercel env add GEMINI_MODEL
```

#### Step 3: デプロイ実行

```bash
# 初回デプロイ
vercel --prod

# 継続的デプロイ（GitHub連携）
git push origin main  # 自動デプロイ
```

### 8.2 デプロイ後確認

-   [ ] フロントエンド動作確認
-   [ ] API エンドポイント確認
-   [ ] AI 機能動作確認
-   [ ] レスポンス時間測定
-   [ ] エラーログ監視

---

## 9. 次回開発セッション準備

### 9.1 事前準備項目

-   [ ] PostgreSQL 環境準備（ElephantSQL 等）
-   [ ] Prisma 学習・理解
-   [ ] データベース設計レビュー
-   [ ] JWT 認証の理解

### 9.2 開発環境確認

```bash
# 現在の環境が正常動作することを確認
cd backend
npm run dev

# 別ターミナルでテスト
curl http://localhost:3001/health/ai
```

### 9.3 必要な技術調査

-   **Prisma ORM**: スキーマ定義、マイグレーション
-   **PostgreSQL**: 本番環境での DB 選択肢
-   **JWT 認証**: セキュアな認証実装
-   **パスワードハッシュ**: bcrypt 等の使用方法

---

## 10. 開発メモ・学んだ教訓

### 10.1 技術的な学び

1. **環境変数管理の重要性**: Windows 環境での.env 読み込み問題
2. **AI API の変化**: モデル名変更等への対応必要性
3. **遅延初期化パターン**: ES Module での初期化順序問題
4. **フォールバック設計**: AI 利用不可時の代替手段の重要性

### 10.2 開発プロセスの学び

1. **段階的開発の効果**: 機能ごとの確実な実装
2. **プロトタイプファーストの価値**: 早期の動作確認
3. **トラブルシューティングの記録**: 同じ問題の再発防止
4. **リアルタイム要件調整**: 開発中の発見による要件修正

### 10.3 今後への教訓

1. **事前設計の重要性**: データベース設計は慎重に
2. **セキュリティ考慮**: 早期段階からの組み込み
3. **スケーラビリティ**: 将来の拡張を意識した設計
4. **ドキュメント化**: 開発プロセスの記録継続

---

## 📊 開発進捗サマリー

| Phase                     | 状況        | 完了率 | 主要成果物                            |
| ------------------------- | ----------- | ------ | ------------------------------------- |
| Phase 1: 基本機能開発     | ✅ 完了     | 100%   | フロントエンド、バックエンド、AI 統合 |
| Phase 2: データベース設計 | 🔄 次回予定 | 0%     | スキーマ設計、Prisma 設定             |
| Phase 3: 機能拡張         | 📋 将来計画 | 0%     | 高度機能、ユーザビリティ向上          |
| Phase 4: 事業化準備       | 📋 将来計画 | 0%     | 有料化、スケーラビリティ対応          |

---

## 📞 参考資料・リンク

-   **Gemini AI API**: https://ai.google.dev/
-   **Vite**: https://vitejs.dev/
-   **Tailwind CSS**: https://tailwindcss.com/
-   **Prisma**: https://www.prisma.io/
-   **Vercel**: https://vercel.com/

---

**最終更新者**: 開発チーム  
**次回更新予定**: Phase 2 完了時

_この開発手順書は各フェーズの完了とともに継続的に更新されます。_
